#!/bin/bash
exec >uperf-server-stderrout.txt 
exec 2>&1
echo "args; $@"
echo
echo "pwd:"
/bin/pwd
echo
echo "ls -alR:"
ls -alR
echo
if [ -z "$RS_CS_LABEL" ]; then
    echo "RS_CS_LABEL not defined, exiting"
    exit 1
else
    echo "RS_CS_LABEL: $RS_CS_LABEL"
fi
echo "hostname: `hostname`"
echo
id=`echo $RS_CS_LABEL | awk -F- '{print $2}'`
re='^[1-9][0-9]*$'
if [[ ! "$id" =~ $re ]]; then
    echo "ID must a be a positive interger, exiting"
    exit 1
fi

# defaults
control_port=""
data_port=""
server_ifname=""

longopts="test-type:,protocol:,rsize:,wsize:,nthreads:,remotehost:,duration:,server-ifname:"
opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
    printf -- "\tUnrecognized option specified\n\n"
    exit 1
fi
eval set -- "$opts";
while true; do
    case "$1" in
        --server-ifname)
            shift;
            server_ifname="$1"
            echo "server_ifname=$server_ifname"
            shift
            ;;
        --test-type|--nthreads|--protocol|--rsize|--wsize|--remotehost|--duration)
            shift;
            shift;
            ;;
        --)
            shift;
            break
            ;;
        *)
            echo "Invalid option: $1"
            exit 1
    esac
done

id=`echo $RS_CS_LABEL | awk -F- '{print $2}'`
re='^[1-9][0-9]*$'
if [[ ! "$id" =~ $re ]]; then
    echo "ID must a be a positive interger, exiting"
    exit 1
fi

# There are always 2 ports for these uperf tests, and ports should always
# start at 30000 to avoid port number reassignment
let "control_port = 2 * $id"
let "control_port = $control_port + 30000"
let "data_port = $control_port + 1"

ip -j a >ip.json

ip=""
# Find the IP of the $server_ifname
if [ ! -z "$server_ifname" ]; then
    echo "--server-ifname=$server_ifname was found, searching for IP"
    # Find the element in the 'ip a' array that matches the ifname we are looking for
    ifname_idx=`jq 'to_entries | .[] | if (.value.ifname == "'$server_ifname'") then .key else null end' ip.json | grep -v null`
    if [ ! -z "$ifname_idx" ]; then
        echo "$server_ifname matches index $ifname_idx, looking for ipv4 (inet) in addr_info:"
        jq '.['$ifname_idx'].addr_info' ip.json
        # Find the first ipv4 address
        addr_idx=`jq '.['$ifname_idx'].addr_info | to_entries | .[] | if (.value.family == "inet") then .key else null end' ip.json | grep -v null | head -1`
        if [ ! -z $addr_idx ]; then
            echo "Found inet in index $addr_idx:"
            jq -r '.['$ifname_idx'].addr_info['$addr_idx']' ip.json
            ip=`jq -r '.['$ifname_idx'].addr_info['$addr_idx'].local' ip.json`
        else
            echo "WARNING: an ipv4 address could not be found for $server_ifname in addr_info:"
            jq '.['$ifname_idx'].addr_info' ip.json
        fi
    else
        echo "WARNING: ifname_idx was not defined when searching for $ifname"
    fi
    if [ -z "$ip" ]; then
        echo "WARNING: IP was not found from $server_ifname"
    else
        echo "IP was found: $ip"
    fi
else
    echo "Not going to look for an IP since --server-ifname was not used."
    echo "Either uperf's bench-params need to include --remotehost, or the endpoint must derive the uperf server's IP"
fi

# Queue ip/port info, to be sent to endpoint
echo '{"recipient":{"type":"all","id":"all"},"user-object":{"svc":{"ip":"'$ip'","ports":['$control_port,$data_port']}}}' >msgs/tx/svc

cmd="uperf -s -P $control_port"
echo "going to run: $cmd"
$cmd 2>&1 >uperf-server-start.txt &
pid=$!
echo $pid >uperf-server.pid
# Wait a little bit to see if the server errored out
sleep 10
if grep -q -i error uperf-server-start.txt; then
    echo "Server failed to start:"
    cat uperf-server-start.txt
    exit 1
fi
echo ps:
ps aux | grep uperf
echo
echo ss -tlnp:
ss -tlnp
